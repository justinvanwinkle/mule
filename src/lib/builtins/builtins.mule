`(defgeneric __hash__ (a))`
`(defgeneric __eq__ (a b))`

defmethod __hash__(a):
    return SXHASH(a)

defmethod __eq__(a, b):
    return EQUAL(a, b)

DEFINE_HASH_TABLE_TEST(__eq__, __hash__)

#`(export '(|__eq__| |__hash__|))`
IN_PACKAGE("builtins")

`(import 'cl-user::|__eq__|)`
`(import 'cl-user::|__hash__|)`




class dict(SEQUENCE, STANDARD_OBJECT):
    def __init__(self, *args):
        self.hash_table = MAKE_HASH_TABLE(TEST=QUOTE(__eq__))

    def len(self):
        return HASH_TABLE_COUNT(self.hash_table)

    def keys(self):
        hashtable = self.hash_table
        lst = list()
        `(loop for key being the hash-keys of |hashtable|
             do (|append| |lst| key))`
        return lst

    def setitem(self, key, value):
        SETF(GETHASH(key, self.hash_table), value)

    def getitem(self, key):
        return GETHASH(key, self.hash_table)

    def MAKE_SEQUENCE_ITERATOR(self, FROM_END=None, START=None, END=None):
        return MAKE_SEQUENCE_ITERATOR(self.hash_table,
                                      FROM_END=FROM_END,
                                      START=START,
                                      END=END)


class list(SEQUENCE, STANDARD_OBJECT):
    def __init__(self, *args):
        self.array = MAKE_ARRAY(0, ADJUSTABLE=True, FILL_POINTER=True)
        for lst in args:
            for x in lst:
                self.append(x)

    def __eq__(self, other):
        if len(self) != len(other):
            return False
        for i in range(len(self)):
            if self[i] != other[i]:
                return False
        return True

    def __hash__(self):
        return hash(self.array)

    def sort(self, order):
        self.array.STABLE_SORT(order)

    def sorted(self):
        return list(SORT(COPY_SEQ(self.array), `#'|__cmp__|`))

    def len(self):
        return LENGTH(self.array)

    def setitem(self, key, value):
        SETF(ELT(self.array, key), value)

    def getitem(self, key):
        return ELT(self.array, key)

    def append(self, val):
        VECTOR_PUSH_EXTEND(val, self.array)

    def `SEQUENCE:LENGTH`(self):
        return LENGTH(self.array)

    def `SEQUENCE:ELT`(self, index):
        return self.getitem(index)

    def MAKE_SEQUENCE_ITERATOR(self, FROM_END=None, START=None, END=None):
        return MAKE_SEQUENCE_ITERATOR(self.array,
                                      FROM_END=FROM_END,
                                      START=START,
                                      END=END)


class tuple(SEQUENCE, STANDARD_OBJECT):
    def __init__(self, *args):
        self.array = MAKE_ARRAY(0, ADJUSTABLE=True, FILL_POINTER=True)
        for lst in args:
            for x in lst:
                self.append(x)

    def len(self):
        return LENGTH(self.array)

    def __hash__(self):
        return hash(self.array)

    def setitem(self, key, value):
        SETF(ELT(self.array, key), value)

    def getitem(self, key):
        return ELT(self.array, key)

    def append(self, val):
        VECTOR_PUSH_EXTEND(val, self.array)

    def `SEQUENCE:LENGTH`(self):
        return LENGTH(self.array)

    def `SEQUENCE:ELT`(self, index):
        return self.getitem(index)

    def MAKE_SEQUENCE_ITERATOR(self, FROM_END=None, START=None, END=None):
        return MAKE_SEQUENCE_ITERATOR(self.array,
                                      FROM_END=FROM_END,
                                      START=START,
                                      END=END)

class str(SEQUENCE, STANDARD_OBJECT):
    def __init__(self, str):
        self._str = str

    def len(self):
        return LENGTH(self._str)

    def __eq__(self, other::str):
        return self == other._str

    def __eq__(self, other::STRING):
        return `STRING=`(self._str, other)

    def __eq__(a::STRING, other::str):
        return other == a

    def __cmp__(self, other::str):
        return `STRING<`(self._str, other._str)

    def __cmp__(self, other::STRING):
        return `STRING<`(self._str, other._str)

    def getitem(self, key):
        return ELT(self.array, key)

    def `SEQUENCE:LENGTH`(self):
        return LENGTH(self._str)

    def `SEQUENCE:ELT`(self, index):
        return self.getitem(index)

    def MAKE_SEQUENCE_ITERATOR(self, FROM_END=None, START=None, END=None):
        return MAKE_SEQUENCE_ITERATOR(self.array,
                                      FROM_END=FROM_END,
                                      START=START,
                                      END=END)


def hash(a):
    return a.__hash__()

defmethod sorted(lst):
    return SORT(COPY_SEQ(lst), `#'|__cmp__|`)

defmethod __cmp__(a, b):
    return SXHASH(a) < SXHASH(b)

defmethod __cmp__(a::NUMBER, b::NUMBER):
    return a < b

defmethod __eq__(a::REAL, b::FIXNUM):
    return not (a > b) and not (a < b)

defmethod __eq__(a::FIXNUM, b::REAL):
    return not (a > b) and not (a < b)

defmethod __hash__(a::FIXNUM):
    return a

defmethod __hash__(a::REAL):
    int_part = ROUND(a)
    if int_part == a:
        return int_part
    return SXHASH(a)
