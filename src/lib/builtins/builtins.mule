IN_PACKAGE("builtins")


class dict:
    def __init__(self, *args):
        self.hash_table = MAKE_HASH_TABLE(TEST=QUOTE(EQUALP))

    def len(self):
        return HASH_TABLE_COUNT(self.hash_table)

    def keys(self):
        hashtable = self.hash_table
        lst = list()
        `(loop for key being the hash-keys of |hashtable|
             do (|append| |lst| key))`
        return lst

    def setitem(self, key, value):
        SETF(GETHASH(key, self.hash_table), value)

    def getitem(self, key):
        return GETHASH(key, self.hash_table)



class list(SEQUENCE, STANDARD_OBJECT):
    def __init__(self, *args):
        self.array = MAKE_ARRAY(0, ADJUSTABLE=True, FILL_POINTER=True)
        for lst in args:
            for x in lst:
                self.append(x)

    def __eq__(self, other):
        if len(self) != len(other):
            return False
        for i in range(len(self)):
            if self[i] != other[i]:
                return False
        return True

    def __hash__(self):
        return SXHASH(self.array)

    def sort(self, order):
        self.array.STABLE_SORT(order)

    def sorted(self):
        return list(SORT(COPY_SEQ(self.array), `#'|__cmp__|`))

    def len(self):
        return LENGTH(self.array)

    def setitem(self, key, value):
        SETF(ELT(self.array, key), value)

    def getitem(self, key):
        return ELT(self.array, key)

    def append(self, val):
        VECTOR_PUSH_EXTEND(val, self.array)

    def `SEQUENCE:LENGTH`(self):
        return LENGTH(self.array)

    def `SEQUENCE:ELT`(self, index):
        return self.getitem(index)

    def MAKE_SEQUENCE_ITERATOR(self, FROM_END=None, START=None, END=None):
        return MAKE_SEQUENCE_ITERATOR(self.array,
                                      FROM_END=FROM_END,
                                      START=START,
                                      END=END)


class tuple(SEQUENCE, STANDARD_OBJECT):
    def __init__(self, *args):
        self.array = MAKE_ARRAY(0, ADJUSTABLE=True, FILL_POINTER=True)
        for lst in args:
            for x in lst:
                self.append(x)

    def len(self):
        return LENGTH(self.array)

    def setitem(self, key, value):
        SETF(ELT(self.array, key), value)

    def getitem(self, key):
        return ELT(self.array, key)

    def append(self, val):
        VECTOR_PUSH_EXTEND(val, self.array)

    def `SEQUENCE:LENGTH`(self):
        return LENGTH(self.array)

    def `SEQUENCE:ELT`(self, index):
        return self.getitem(index)

    def MAKE_SEQUENCE_ITERATOR(self, FROM_END=None, START=None, END=None):
        return MAKE_SEQUENCE_ITERATOR(self.array,
                                      FROM_END=FROM_END,
                                      START=START,
                                      END=END)

class str(SEQUENCE, STANDARD_OBJECT):
    def __init__(self, str):
        self._str = str

    def len(self):
        return LENGTH(self._str)

    def __eq__(self, other::str):
        return self == other._str

    def __eq__(self, other::STRING):
        return `STRING=`(self._str, other)

    def __eq__(a::STRING, other::str):
        return other == a

    def __cmp__(self, other::str):
        return `STRING<`(self._str, other._str)

    def __cmp__(self, other::STRING):
        return `STRING<`(self._str, other._str)

    def getitem(self, key):
        return ELT(self.array, key)

    def `SEQUENCE:LENGTH`(self):
        return LENGTH(self._str)

    def `SEQUENCE:ELT`(self, index):
        return self.getitem(index)

    def MAKE_SEQUENCE_ITERATOR(self, FROM_END=None, START=None, END=None):
        return MAKE_SEQUENCE_ITERATOR(self.array,
                                      FROM_END=FROM_END,
                                      START=START,
                                      END=END)

defmethod __hash__(a):
    return SXHASH(a)

defmethod __eq__(a, b):
    return EQUAL(a, b)

defmethod sorted(lst):
    return SORT(COPY_SEQ(lst), `#'|__cmp__|`)

defmethod __cmp__(a, b):
    return SXHASH(a) < SXHASH(b)

defmethod __cmp__(a::NUMBER, b::NUMBER):
    return a < b
